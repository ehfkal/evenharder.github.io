---
title: "2020년 1월 말/2월 초 Problem Solving"
date: 2020-02-04 17:30
last_modified_at:   2020-02-09 11:00
categories:
  - algo
tags:
  - PS
excerpt_separator: <!--more-->
toc: true

---

풀려는 문제를 연습대회로 만들어서 풀기로 마음먹었습니다.

<!--more-->

원래 풀고자 하는 문제들을 목록으로 만들어서 이 문제들만 보려고 했는데, 각 문제들과
같은 대회에 있었던 문제들 중에서도 재밌어보이는 게 많아 그냥 멋대로 잡탕처럼 풀기로 했습니다.

1월 말~2월 초에 검수자로 들어가 있는 대회가 2개나 있어서 그동안은 2문제밖에 못 풀었고, 개인적인 일도 겹쳐서 2월 4일이 되어서야 새로 문제를 풀기 시작했습니다.

# 2020.01.23

## The Dragon and the knights (CERC 2012 I번)

직선을 잘 정렬한 다음, 점도 정렬해서 sweeping하듯이 각 $y$축 구간별로 점들이 몇 개 포함되는지 체크하고, 교점을 만나면 구간의 정보를 초기화시켜주는 방법을 짜보았으나 잘 진행되지 않았고 코딩도 많이 까다로웠습니다. 그런데 1KB 이내로 짠 사람들이 많아서 결국 풀이를 보고 감명받은 문제입니다.

각 점이 있는 구역을 어떻게 표시할 수 있을까요? $N$개의 직선에 대해서 위아래 유무를 2진법으로 생각한 다음 $N$자리 2진수를 만들여 표시할 수 있습니다. 이러면 각 구역마다 유일한 2진수들을 가지게 됩니다. 그러므로 각 기사마다 이를 조사하여, 총 몇 개의 다른 구역에 기사들이 있는지 셀 수 있습니다. $O(NM)$에 조사하고, $O(M \lg M)$에 정렬하면 끝입니다.

직선으로 나뉜 전체 구역의 개수는 굳이 오일러의 공식까지 가지 않아도, "1 + 직선 개수 + 교점 개수"가 됨을 알 수 있습니다. 그러므로 두 값을 비교하여 같으면 `PROTECTED`, 다르면 `VULNERABLE`을 출력하면 됩니다.



## 삼각 분할 (BOI 2009 5번)

옛날부터 알고 있는 문제였는데, 갑자기 풀이가 떠올라서 금방 풀 수 있었습니다.

삼각 분할 관계 트리로 변환하여 생각할 수 있으므로, 결국 이 문제는 "트리의 각 노드를 특정한 색으로 칠할 때, 같은 색인 임의의 두 노드가 연결되어 있도록 할 때 최대한 제거할 수 있는 간선의 수를 구하는 문제"로 환원됩니다.

달리 생각하면 같은 색인 임의의 두 노드를 연결하는 방식으로도 할 수 있으므로, rooted tree를 구성한 다음 색깔이 같은 두 노드를 disjoint-set을 통해서 LCA랑 잘 합치는 방법으로 해결할 수 있습니다. 즉 LCA랑 두 노드가 같은 집합이 되게 합치는 과정을 반복하면 됩니다. merge를 할 때는 root에 가까운 쪽을 root로 설정하는 게 편합니다. 병합은 최대 간선 개수만큼 일어나고, LCA를 찾는 것도 $O(\lg N)$에 가능하므로 시간 복잡도 상으로도 충분합니다.

다른 분 풀이를 보니 단절점/단절선으로 접근할 수 있는 것 같은데, 깊게 생각해보진 않았습니다.

# 2020.01.24 ~ 02.02

개인적인 일도 겹치고, 제1 전시관 검수도 당시 상황에서 최선을 다했습니다. 정말 어려웠지만 덕분에 많이 배웠습니다.

# 2020.02.04

연습셋의 기간도 갱신하고 새롭게 시작하였습니다.

## 레스토랑 (COCI 2009/2010 Contest #7 6번)

그래프의 간선을 빨간색 또는 파란색으로 칠하는데, 연결된 간선이 2개 이상 있는 모든 정점에 대해 최소 빨간 간선 하나와 파란 간선 하나가 연결되어있도록 칠하는 방법을 구하는 문제입니다.

빨간 간선과 파란 간선을 그래프 순회를 할 때 "들어왔다가 나가는 것"으로 해석해볼 수 있습니다. 들어올 때와 나갈 때의 색깔을 다르게 칠하면 되기 때문입니다. 때문에 트리나 길이가 짝수인 사이클은 교대로 색을 칠하면 가능함을 알 수 있고, 길이가 홀수인 사이클은 어떻게 해도 불가능함을 알 수 있습니다.

그럼 조금 더 일반적인 그래프일 때는 어떨까요? 다음과 같이 접근해볼 수 있습니다.

+ 우선, 간선 1개(degree가 1)와 연결된 모든 정점에 대해 오일러 투어를 합니다. 말이 오일러 투어지, 사용되지 않은 간선에 대해 DFS를 하겠다는 뜻입니다. 중간에 indegree가 1개뿐인 정점이 생성되면 queue에 넣어서 모두 처리해줍니다.
  + degree가 1인 정점을 미리 처리하는 이유는, 기본적으로 오일러 투어는 자기 자신으로 돌아오는 회로를 찾기 떄문입니다. 그러나 degree가 1이면 돌아올 수도 없고, 다른 정점의 오일러 투어를 방해할 수 있습니다.
+ 이후, degree가 3 이상인 모든 정점에 대해 오일러 투어를 합니다. 당연히 윗 과정에서 사용한 간선은 제외하고 세어야 합니다. leaf가 없기 때문에, 간선 3개 이상 연결된 모든 정점은 자기 자신으로 돌아오는 순회가 존재합니다. 때문에 첫 순회에서 나가는 간선을 빨간색으로 칠했고, 다시 이 정점에서 순회를 시작하게 되면 파란색으로 칠하면 됩니다. 순회 중간에 파란색을 통해 다시 간선으로 돌아오면 아무래도 상관 없습니다.
+ 마지막으로 간선 2개와 연결된 모든 정점에 대해 오일러 투어를 합니다. (확실하진 않지만) 사이클만 남아 있을 것입니다.

때문에 이 문제에서는 오일러 투어를 할 때 parity을 넣어주어야 할 뿐만 아니라, 같은 정점에서도 다음 정점을 갈 때마다 자기 자신의 parity를 바꾸어주어야 합니다. 그래야 다른 색깔의 간선을 칠할 수 있기 때문입니다.

이 과정을 거치며 적당히 각 정점에 무슨 색 간선들이 있는지 기록하고, 마지막에 확인하면 됩니다. 그래프 이론에 대한 관찰과, 오일러 투어에 parity를 넣는 접근이 동반되어야 해결할 수 있는 문제였습니다.

처음 풀 때는 parity까진 접근했었지만 정점 내부에서 parity를 바꾸어주며 탐색해야 한다는 생각은 하지 못했었는데, 다행히 다음 반례를 발견하였습니다.

```
7 7
1 2
1 3
3 4
4 1
2 5
5 6
6 2
```

이러면 degree가 1인 정점이 없기 때문에 degree가 3인 1번 정점부터 시작하게 되는데, 오일러 투어 함수에서 두 번째 탐색시 색을 바꾸지 않으면 (1,2), (1,3), (4,1)이 모두 같은 색을 가지게 됩니다.

# 2020.02.05

## L퍼즐 (NWERC 2011 D번)

인접한 B와 W가 연결되어 있냐를 boolean 변수로 저장한다고 할 때, B 기준 가로 / 세로별로 1개씩 연결되어야 있어야 하므로 `(A || B) && (~A || ~B)`가 성립해야 합니다. 여기까지는 생각했었는데, W는 모든 인접한 B에 1개 연결되어 있어야 한다는 점을 잘 모르겠어서 풀이를 봤는데, 왜 생각하지 못했을까 싶을 정도로 단순하게 풀렸습니다.

W 옆에 있는 B와의 연결 유무 변수를 `A, B, C, ...`라고 하면, 서로 다른 변수들끼리 `~A || ~B`를 해주면 됩니다. 이러면 두 개 이상 참이 되는 변수가 없음을 알 수 있습니다. 그 외의 다른(W 옆에 있는 W나 . 등등) 변수들은 거짓으로 설정 (`~A || ~A`)해주면 됩니다. 이러면 W 기준으로 1개 이상 연결되어야 한다는 건 B쪽에서, 1개 이하로 연결되어야 한다는 건 W쪽에서 처리가 되어 2-SAT을 돌리면 됩니다. 물론, B : W = 1 : 2인 건 확인해주어야 합니다.

홀짝성을 이용해 2-SAT 없이도 풀 수 있는 것 같으나, 나중에 이해해보기로 했습니다.



## Crocodile's Underground City (IOI 2011 4번) 

1년 전에 풀고 실패했을 때는 난맞왜틀을 했었는데, 지금 보니 괜히 IOI에서 100명 이상 맞은 문제가 아닌가 싶습니다.

탈출구에서는 자명하게 바로 탈출할 수 있습니다. 나머지는 최소 2개의 '탈출할 수 있는 정점'과 인접해야 합니다. 안 그러면 탈출할 수 있는 정점 쪽 통로를 막아버리면 되기 때문입니다. 때문에 탈출구를 전부 초깃값 (거리 0)으로 설정해서 다익스트라 알고리즘을 사용하되, 두 번째로 방문했을 때만 값을 취하면 됩니다. 첫 번째로 도달했을 때의 경로가 일반적으로 최적이지만, 문지기가 막아버릴 것이기 때문입니다. 그리고 문제 조건에 의해 두 번째로도 도달할 수 있음이 보장되며, 탈출구가 아닌 다른 정점은 이런 식으로 거리를 계산해야 함이 보여집니다.

코드도 간결합니다. 역시 IOI 문제입니다.

# 2020.02.06

IOI 2011 Elephants를 Crocodile을 풀고 접했는데, 제가 개인적으로 생각하고 있던 문제랑 놀랍도록 일치해서 꼭 풀어봐야겠다고 마음먹었습니다. 풀이는 백날 생각해도 모르겠어서 핵심 아이디어만 슬쩍 보았는데 정말, 정말 감동받았습니다. 깊은 충격을 받고 일부러 구현 쪽 설명과 코드는 검색해보지 않았는데 아직 구현을 어떻게 해야 할지 구체화가 되지 않았습니다. 금방 풀 수 있기를 바라며...

## N의 존재 (AMPPZ 2008 I번)

대신 오늘의 뜨거운 감자를 풀었습니다. [Text로 1을 찍어내도 맞는다는 기상천외한 스페셜 저지](https://www.acmicpc.net/board/view/46220)가 발견된 문제입니다. 이전에 이미 baby-step giant step을 테스트해보려고 점찍어놓았던 문제인데 이번 기회에 풀어보았습니다.

전반적인 풀이의 설명과 증명은 [rkm0959님의 포스트](https://rkm0959.tistory.com/77)를 참고해주시길 바랍니다.

# 2020.02.07
코끼리한테 짖밟혔습니다. :cry: 열심히 구현하고 예제가 나와서 제출까지 했으나, 놓친 점이 좀 있는 것 같습니다. 날 잡고 다른 분 코드 보면서 고민해봐야겠습니다...

주말에는 제2회 IDTcup이 열리는지라 코끼리만 잡고 있을 것 같진 않습니다.

# 2020.02.08
IDTcup은 일요일에 좀 보려고 합니다. 천신만고 끝에 코끼리를 풀었습니다.

## Find C (ACM-ICPC 2016 Bangkok Regional D번)
이전에 어떻게 풀지하며 방치했었는데 오늘 갑자기 풀이가 떠올랐습니다.

한 격자점을 원점으로 평행이동시켜봅시다. 이 문제를 잘 생각해보면, 두 격자점을 잇는 직선을 아주 약간 윗쪽으로 평행이동하는 걸 생각해볼 수 있습니다. 그러면 기존의 직선의 방정식 $ax + by = 0$이 $ax + by = \gcd(a, b)$로 옮겨갈 수 있음을 볼 수 있고, 이 직선 위의 격자점이 그대로 정답이 됩니다. 두 직선 사이에 격자점이 전혀 없기 때문입니다. 이 성질에 대해 조금 더 자세히 알고 싶다면 정수론의 기초 성질 중 하나인 [Bézout's identity](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity)를 참고해주세요.

여기까지 도달했으면 남은 건 별 거 없습니다. 확장 유클리드 호제법을 이용해서 격자점을 숭숭 찍어내고 적당히 대칭/평행이동 시켜서 답을 구하면 됩니다. 제가 사용하는 C++14로 작성된 확장 유클리드 호제법 코드입니다.
```c++
using ll = long long;
using pll = std::pair<ll, ll>;
// ax + by = gcd(a,b). x, y?
pll ext_gcd(ll a, ll b) {
    if(b) {
        ll p, q;
        std::tie(p, q) = ext_gcd(b, a%b);
        return {q, p - (a/b) * q};
    }
    return {1, 0};
}
```

## Dancing Elephants (IOI 2011 5번)
어떻게 $O(\sqrt{n})$에 삽입 삭제를 관리하는지 도저히 모르겠어서 풀이를 보았습니다. 다양하게 접근을 할 수 있을 것 같지만 제가 이해하고 짠 풀이는 다음과 같습니다.

우선, 크기 $O(\sqrt{N})$의 버킷을 $O(\sqrt{N})$개 만듭니다. 각 버킷별로 세 개의 배열을 저장합니다. 첫 번째는 코끼리들의 오름차순 좌표입니다. 두 번째는 이 코끼리부터 이 그룹의 마지막 코끼리까지 찍는데 필요한 카메라 수(`cnt`)입니다. 세 번째는 이 코끼리부터 이 그룹의 마지막 코끼리까지 찍을 때, 카메라가 촬영할 수 있는 가장 높은 좌표값(`nxt`)입니다. 버킷의 크기가 $S$라고 하면, 슬라이딩 윈도우와 간단한 동적 계획법을 통해 $O(S)$에 뒤의 두 값 모두 구할 수 있습니다.

코끼리를 더하고 제거하는 과정도 간단히 생각해봅시다. 배열을 밀면 됩니다! 역시 $O(S)$에 해결할 수 있고, 다시 위의 값을 계산해주면 됩니다. 제거하는 건 존재성이 증명되므로 간단하지만 삽입하는 건 약간 생각해주어야 할 부분이 있습니다.

그럼 이 상황에서 답은 어떻게 구할까요? 마지막으로 찍힌 코끼리의 좌표를 $x$라고 하면, 매 버킷별로 이 $x$의 upper bound를 찾아, 거기 있는 코끼리부터 찍으면 됨을 알 수 있습니다. 만약 이에 해당하는 코끼리가 있다면, 조사해놓은 `cnt`값을 (정의에 의해) 그대로 정답에 더하면 됩니다. 이후, $x$를 해당하는 `nxt`값으로 갱신해주면 됩니다.

이러면 쿼리당 $O(\sqrt{N} \lg{N})$ 정도에 해결할 수 있습니다. 이러면 점점 버킷의 균일함이 깨지므로 $O(\sqrt{N})$번마다 그룹을 다시 만들어주면 됩니다. 다시 버킷을 구성하는 과정은 $O(N)$이나 $O(N \lg N)$ 정도에 할 수 있으며, $O(\frac{M}{\sqrt{N}})$번 정도만 하면 되므로 총 시간 복잡도는 $O((N + M) \sqrt{N} \lg{N})$이 됩니다.

Link-cut tree 등의 자료구조를 이용하면 시간복잡도에서 루트를 떼어버릴 수 있는 것 같습니다.


